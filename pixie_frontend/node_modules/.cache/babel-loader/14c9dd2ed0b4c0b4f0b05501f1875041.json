{"ast":null,"code":"'use strict';\n/* eslint max-depth: [\"error\", 4] */\n\nvar sameOrigin = require('same-origin');\n\nvar parseHeaders = require('parse-headers');\n\nvar FetchXhr = require('./browser/fetchXhr');\n\nvar noop = function noop() {\n  /* intentional noop */\n};\n\nvar win = typeof window === 'undefined' ? undefined : window;\nvar adapter = win ? 'xhr' : 'fetch';\nvar XmlHttpRequest = typeof XMLHttpRequest === 'function' ? XMLHttpRequest : noop;\nvar hasXhr2 = ('withCredentials' in new XmlHttpRequest());\nvar XDR = typeof XDomainRequest === 'undefined' ? undefined : XDomainRequest;\nvar CrossDomainRequest = hasXhr2 ? XmlHttpRequest : XDR; // Fallback to fetch-based XHR polyfill for non-browser environments like Workers\n\nif (!win) {\n  XmlHttpRequest = FetchXhr;\n  CrossDomainRequest = FetchXhr;\n}\n\nmodule.exports = function (context, callback) {\n  var opts = context.options;\n  var options = context.applyMiddleware('finalizeOptions', opts);\n  var timers = {}; // Deep-checking window.location because of react native, where `location` doesn't exist\n\n  var cors = win && win.location && !sameOrigin(win.location.href, options.url); // Allow middleware to inject a response, for instance in the case of caching or mocking\n\n  var injectedResponse = context.applyMiddleware('interceptRequest', undefined, {\n    adapter: adapter,\n    context: context\n  }); // If middleware injected a response, treat it as we normally would and return it\n  // Do note that the injected response has to be reduced to a cross-environment friendly response\n\n  if (injectedResponse) {\n    var cbTimer = setTimeout(callback, 0, null, injectedResponse);\n\n    var cancel = function cancel() {\n      return clearTimeout(cbTimer);\n    };\n\n    return {\n      abort: cancel\n    };\n  } // We'll want to null out the request on success/failure\n\n\n  var xhr = cors ? new CrossDomainRequest() : new XmlHttpRequest();\n  var isXdr = win && win.XDomainRequest && xhr instanceof win.XDomainRequest;\n  var headers = options.headers;\n  var delays = options.timeout; // Request state\n\n  var aborted = false;\n  var loaded = false;\n  var timedOut = false; // Apply event handlers\n\n  xhr.onerror = onError;\n  xhr.ontimeout = onError;\n\n  xhr.onabort = function () {\n    aborted = true;\n  }; // IE9 must have onprogress be set to a unique function\n\n\n  xhr.onprogress = function () {\n    /* intentional noop */\n  };\n\n  var loadEvent = isXdr ? 'onload' : 'onreadystatechange';\n\n  xhr[loadEvent] = function () {\n    // Prevent request from timing out\n    resetTimers();\n\n    if (aborted || xhr.readyState !== 4 && !isXdr) {\n      return;\n    } // Will be handled by onError\n\n\n    if (xhr.status === 0) {\n      return;\n    }\n\n    onLoad();\n  }; // @todo two last options to open() is username/password\n\n\n  xhr.open(options.method, options.url, true // Always async\n  ); // Some options need to be applied after open\n\n  xhr.withCredentials = !!options.withCredentials; // Set headers\n\n  if (headers && xhr.setRequestHeader) {\n    for (var key in headers) {\n      if (headers.hasOwnProperty(key)) {\n        xhr.setRequestHeader(key, headers[key]);\n      }\n    }\n  } else if (headers && isXdr) {\n    throw new Error('Headers cannot be set on an XDomainRequest object');\n  }\n\n  if (options.rawBody) {\n    xhr.responseType = 'arraybuffer';\n  } // Let middleware know we're about to do a request\n\n\n  context.applyMiddleware('onRequest', {\n    options: options,\n    adapter: adapter,\n    request: xhr,\n    context: context\n  });\n  xhr.send(options.body || null); // Figure out which timeouts to use (if any)\n\n  if (delays) {\n    timers.connect = setTimeout(function () {\n      return timeoutRequest('ETIMEDOUT');\n    }, delays.connect);\n  }\n\n  return {\n    abort: abort\n  };\n\n  function abort() {\n    aborted = true;\n\n    if (xhr) {\n      xhr.abort();\n    }\n  }\n\n  function timeoutRequest(code) {\n    timedOut = true;\n    xhr.abort();\n    var error = new Error(code === 'ESOCKETTIMEDOUT' ? 'Socket timed out on request to ' + options.url : 'Connection timed out on request to ' + options.url);\n    error.code = code;\n    context.channels.error.publish(error);\n  }\n\n  function resetTimers() {\n    if (!delays) {\n      return;\n    }\n\n    stopTimers();\n    timers.socket = setTimeout(function () {\n      return timeoutRequest('ESOCKETTIMEDOUT');\n    }, delays.socket);\n  }\n\n  function stopTimers() {\n    // Only clear the connect timeout if we've got a connection\n    if (aborted || xhr.readyState >= 2 && timers.connect) {\n      clearTimeout(timers.connect);\n    }\n\n    if (timers.socket) {\n      clearTimeout(timers.socket);\n    }\n  }\n\n  function onError(error) {\n    if (loaded) {\n      return;\n    } // Clean up\n\n\n    stopTimers();\n    loaded = true;\n    xhr = null; // Annoyingly, details are extremely scarce and hidden from us.\n    // We only really know that it is a network error\n\n    var err = error || new Error('Network error while attempting to reach ' + options.url);\n    err.isNetworkError = true;\n    err.request = options;\n    callback(err);\n  }\n\n  function reduceResponse() {\n    var statusCode = xhr.status;\n    var statusMessage = xhr.statusText;\n\n    if (isXdr && statusCode === undefined) {\n      // IE8 CORS GET successful response doesn't have a status field, but body is fine\n      statusCode = 200;\n    } else if (statusCode > 12000 && statusCode < 12156) {\n      // Yet another IE quirk where it emits weird status codes on network errors\n      // https://support.microsoft.com/en-us/kb/193625\n      return onError();\n    } else {\n      // Another IE bug where HTTP 204 somehow ends up as 1223\n      statusCode = xhr.status === 1223 ? 204 : xhr.status;\n      statusMessage = xhr.status === 1223 ? 'No Content' : statusMessage;\n    }\n\n    return {\n      body: xhr.response || xhr.responseText,\n      url: options.url,\n      method: options.method,\n      headers: isXdr ? {} : parseHeaders(xhr.getAllResponseHeaders()),\n      statusCode: statusCode,\n      statusMessage: statusMessage\n    };\n  }\n\n  function onLoad() {\n    if (aborted || loaded || timedOut) {\n      return;\n    }\n\n    if (xhr.status === 0) {\n      onError(new Error('Unknown XHR error'));\n      return;\n    } // Prevent being called twice\n\n\n    stopTimers();\n    loaded = true;\n    callback(null, reduceResponse());\n  }\n};","map":{"version":3,"sources":["../../src/request/browser-request.js"],"names":["sameOrigin","require","parseHeaders","FetchXhr","noop","win","adapter","XmlHttpRequest","hasXhr2","XDR","CrossDomainRequest","module","opts","context","options","timers","cors","injectedResponse","cbTimer","setTimeout","cancel","clearTimeout","abort","xhr","isXdr","headers","delays","aborted","loaded","timedOut","loadEvent","resetTimers","onLoad","request","timeoutRequest","error","code","stopTimers","err","callback","statusCode","statusMessage","onError","body","url","method","reduceResponse"],"mappings":"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","sourcesContent":["/* eslint max-depth: [\"error\", 4] */\nconst sameOrigin = require('same-origin')\nconst parseHeaders = require('parse-headers')\nconst FetchXhr = require('./browser/fetchXhr')\n\nconst noop = function() {\n  /* intentional noop */\n}\n\nconst win = typeof window === 'undefined' ? undefined : window\nconst adapter = win ? 'xhr' : 'fetch'\n\nlet XmlHttpRequest = typeof XMLHttpRequest === 'function' ? XMLHttpRequest : noop\nconst hasXhr2 = 'withCredentials' in new XmlHttpRequest()\nconst XDR = typeof XDomainRequest === 'undefined' ? undefined : XDomainRequest\nlet CrossDomainRequest = hasXhr2 ? XmlHttpRequest : XDR\n\n// Fallback to fetch-based XHR polyfill for non-browser environments like Workers\nif (!win) {\n  XmlHttpRequest = FetchXhr\n  CrossDomainRequest = FetchXhr\n}\n\nmodule.exports = (context, callback) => {\n  const opts = context.options\n  const options = context.applyMiddleware('finalizeOptions', opts)\n  const timers = {}\n\n  // Deep-checking window.location because of react native, where `location` doesn't exist\n  const cors = win && win.location && !sameOrigin(win.location.href, options.url)\n\n  // Allow middleware to inject a response, for instance in the case of caching or mocking\n  const injectedResponse = context.applyMiddleware('interceptRequest', undefined, {\n    adapter,\n    context\n  })\n\n  // If middleware injected a response, treat it as we normally would and return it\n  // Do note that the injected response has to be reduced to a cross-environment friendly response\n  if (injectedResponse) {\n    const cbTimer = setTimeout(callback, 0, null, injectedResponse)\n    const cancel = () => clearTimeout(cbTimer)\n    return {abort: cancel}\n  }\n\n  // We'll want to null out the request on success/failure\n  let xhr = cors ? new CrossDomainRequest() : new XmlHttpRequest()\n\n  const isXdr = win && win.XDomainRequest && xhr instanceof win.XDomainRequest\n  const headers = options.headers\n  const delays = options.timeout\n\n  // Request state\n  let aborted = false\n  let loaded = false\n  let timedOut = false\n\n  // Apply event handlers\n  xhr.onerror = onError\n  xhr.ontimeout = onError\n  xhr.onabort = () => {\n    aborted = true\n  }\n\n  // IE9 must have onprogress be set to a unique function\n  xhr.onprogress = () => {\n    /* intentional noop */\n  }\n\n  const loadEvent = isXdr ? 'onload' : 'onreadystatechange'\n  xhr[loadEvent] = () => {\n    // Prevent request from timing out\n    resetTimers()\n\n    if (aborted || (xhr.readyState !== 4 && !isXdr)) {\n      return\n    }\n\n    // Will be handled by onError\n    if (xhr.status === 0) {\n      return\n    }\n\n    onLoad()\n  }\n\n  // @todo two last options to open() is username/password\n  xhr.open(\n    options.method,\n    options.url,\n    true // Always async\n  )\n\n  // Some options need to be applied after open\n  xhr.withCredentials = !!options.withCredentials\n\n  // Set headers\n  if (headers && xhr.setRequestHeader) {\n    for (const key in headers) {\n      if (headers.hasOwnProperty(key)) {\n        xhr.setRequestHeader(key, headers[key])\n      }\n    }\n  } else if (headers && isXdr) {\n    throw new Error('Headers cannot be set on an XDomainRequest object')\n  }\n\n  if (options.rawBody) {\n    xhr.responseType = 'arraybuffer'\n  }\n\n  // Let middleware know we're about to do a request\n  context.applyMiddleware('onRequest', {options, adapter, request: xhr, context})\n\n  xhr.send(options.body || null)\n\n  // Figure out which timeouts to use (if any)\n  if (delays) {\n    timers.connect = setTimeout(() => timeoutRequest('ETIMEDOUT'), delays.connect)\n  }\n\n  return {abort}\n\n  function abort() {\n    aborted = true\n\n    if (xhr) {\n      xhr.abort()\n    }\n  }\n\n  function timeoutRequest(code) {\n    timedOut = true\n    xhr.abort()\n    const error = new Error(\n      code === 'ESOCKETTIMEDOUT'\n        ? `Socket timed out on request to ${options.url}`\n        : `Connection timed out on request to ${options.url}`\n    )\n    error.code = code\n    context.channels.error.publish(error)\n  }\n\n  function resetTimers() {\n    if (!delays) {\n      return\n    }\n\n    stopTimers()\n    timers.socket = setTimeout(() => timeoutRequest('ESOCKETTIMEDOUT'), delays.socket)\n  }\n\n  function stopTimers() {\n    // Only clear the connect timeout if we've got a connection\n    if (aborted || (xhr.readyState >= 2 && timers.connect)) {\n      clearTimeout(timers.connect)\n    }\n\n    if (timers.socket) {\n      clearTimeout(timers.socket)\n    }\n  }\n\n  function onError(error) {\n    if (loaded) {\n      return\n    }\n\n    // Clean up\n    stopTimers()\n    loaded = true\n    xhr = null\n\n    // Annoyingly, details are extremely scarce and hidden from us.\n    // We only really know that it is a network error\n    const err = error || new Error(`Network error while attempting to reach ${options.url}`)\n    err.isNetworkError = true\n    err.request = options\n    callback(err)\n  }\n\n  function reduceResponse() {\n    let statusCode = xhr.status\n    let statusMessage = xhr.statusText\n\n    if (isXdr && statusCode === undefined) {\n      // IE8 CORS GET successful response doesn't have a status field, but body is fine\n      statusCode = 200\n    } else if (statusCode > 12000 && statusCode < 12156) {\n      // Yet another IE quirk where it emits weird status codes on network errors\n      // https://support.microsoft.com/en-us/kb/193625\n      return onError()\n    } else {\n      // Another IE bug where HTTP 204 somehow ends up as 1223\n      statusCode = xhr.status === 1223 ? 204 : xhr.status\n      statusMessage = xhr.status === 1223 ? 'No Content' : statusMessage\n    }\n\n    return {\n      body: xhr.response || xhr.responseText,\n      url: options.url,\n      method: options.method,\n      headers: isXdr ? {} : parseHeaders(xhr.getAllResponseHeaders()),\n      statusCode: statusCode,\n      statusMessage: statusMessage\n    }\n  }\n\n  function onLoad() {\n    if (aborted || loaded || timedOut) {\n      return\n    }\n\n    if (xhr.status === 0) {\n      onError(new Error('Unknown XHR error'))\n      return\n    }\n\n    // Prevent being called twice\n    stopTimers()\n    loaded = true\n    callback(null, reduceResponse())\n  }\n}\n"]},"metadata":{},"sourceType":"script"}